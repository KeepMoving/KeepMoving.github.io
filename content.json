{"meta":{"title":"互联网实践者","subtitle":"阅读使人充实，写作使人精确","description":null,"author":"Wayne Wang","url":"http://yoursite.com"},"pages":[{"title":"my first page","date":"2019-02-09T08:53:55.000Z","updated":"2019-02-09T08:53:55.524Z","comments":true,"path":"my-first-page/index.html","permalink":"http://yoursite.com/my-first-page/index.html","excerpt":"","text":""}],"posts":[{"title":"也谈HashMap实现原理","slug":"也谈HashMap实现原理","date":"2019-02-17T06:20:53.000Z","updated":"2019-02-17T06:25:07.548Z","comments":true,"path":"2019/02/17/也谈HashMap实现原理/","link":"","permalink":"http://yoursite.com/2019/02/17/也谈HashMap实现原理/","excerpt":"","text":"HashMap在互联网应用中是一个老生常谈的话题。从redis等各类缓存到spring内部BeanDefinition的存储，都能看到HashMap的身影。可见hashMap这个数据结构的重要性。 最近也在重看HashMap的结构，记录一下，希望能有一个不一样的启发。","categories":[],"tags":[]},{"title":"ReflectionUtils详解","slug":"ReflectionUtils详解","date":"2019-02-14T10:23:56.000Z","updated":"2019-02-14T10:23:56.095Z","comments":true,"path":"2019/02/14/ReflectionUtils详解/","link":"","permalink":"http://yoursite.com/2019/02/14/ReflectionUtils详解/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"yilia主题的hexo如何集成gitalk评论插件","slug":"yilia主题的hexo如何集成gitalk评论插件","date":"2019-02-11T08:20:20.000Z","updated":"2019-02-11T11:15:06.382Z","comments":true,"path":"2019/02/11/yilia主题的hexo如何集成gitalk评论插件/","link":"","permalink":"http://yoursite.com/2019/02/11/yilia主题的hexo如何集成gitalk评论插件/","excerpt":"","text":"gitalk是一个利用Github API,基于Github issue和Preact开发的评论插件，使用github账号登录,支持markdown语法,和hexo集成也比较简单 阅读这篇文章的朋友注意了，本文是基于yilia主题的hexo，如果是其他主题，可能配置会有一些差异 第一、首先需要在github上新建一个OAuth Apps，方法是在右上角头像下的settings-&gt;developer settings新建 第二、在hexo安装目录的\\themes\\yilia\\layout_partial\\post文件夹中新建gitalk.ejs,代码如下12345678910111213141516&lt;div class=&quot;gitalk&quot;&gt; &lt;div id=&quot;gitalk-container&quot;&gt;&lt;/div&gt; &lt;script src=&quot;/lib/md5/md5.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; const gitalk = new Gitalk(&#123; clientID: &apos;&lt;%=theme.gitalk.client_id%&gt;&apos;, clientSecret: &apos;&lt;%=theme.gitalk.client_secret%&gt;&apos;, repo: &apos;&lt;%=theme.gitalk.repo%&gt;&apos;, owner: &apos;&lt;%=theme.gitalk.owner%&gt;&apos;, admin: &apos;&lt;%=theme.gitalk.admin%&gt;&apos;, id: md5(location.pathname), // Ensure uniqueness and length less than 50 distractionFreeMode: false // Facebook-like distraction free mode &#125;) gitalk.render(&apos;gitalk-container&apos;) &lt;/script&gt;&lt;/div&gt; 其中clientID和clientSecret是上一步注册OAuth Apps后得到的key和secretrepo是存放评论的仓库名，owner和admin是你github的登录名注意这里id有一个md5的函数(这是一个坑，后面会说明)，需要引入1&lt;script src=&quot;/lib/md5/md5.min.js&quot;&gt;&lt;/script&gt; 这个md5的js可以从github上搜索下载到，存放路径是主题source文件夹下，例如hexo\\themes\\yilia\\source\\lib 第三、在hexo\\themes\\yilia\\layout_partial\\article.ejs文件后加上1234567&lt;% if (!index &amp;&amp; theme.gitalk.enable &amp;&amp; post.comments)&#123; %&gt;&lt;%- partial(&apos;post/gitalk&apos;, &#123; key: post.slug, title: post.title, url: config.url+url_for(post.path) &#125;) %&gt;&lt;% &#125; %&gt; 其中post/gitalk是gitalk.ejs文件的相对路径 最后、修改根目录下的_config.yml，在最后加上123456789# 注释所有畅言配置# 配置gitalkgitalk: enable: true client_id: 你申请的clientId client_secret: 你申请的clientSecret repo: 博客仓库的名称 owner: &apos;你github的用户名&apos; admin: &apos;你github的用户名&apos; 最后的最后，重新发布hexo即可 至于上面第二步为啥要加上md5函数，是因为用原始的id，会因为文章名称过长，导致gitalk初始化失败登陆后显示Error: Validation Failed.同时无法进行评论，评论框可以编辑 网页错误信息如下12345Failed to load resource: the server responded with a status of 422 (Unprocessable Entity)gitalk.jsx:127 err: Error: Request failed with status code 422 at e.exports (https://unpkg.com/gitalk@1.2.2/dist/gitalk.min.js:1:34270) at e.exports (https://unpkg.com/gitalk@1.2.2/dist/gitalk.min.js:19:1283) at XMLHttpRequest.h.(anonymous function) (https://unpkg.com/gitalk@1.2.2/dist/gitalk.min.js:1:33269) 另外，如果根目录下_config.yml中的repo参数不对，打开评论页面后会报Error:Not Found错误","categories":[],"tags":[{"name":"博客","slug":"博客","permalink":"http://yoursite.com/tags/博客/"}]},{"title":"互联网从业5年的一些感悟","slug":"互联网从业5年的一些感悟","date":"2019-02-11T06:25:22.000Z","updated":"2019-02-11T06:25:22.915Z","comments":true,"path":"2019/02/11/互联网从业5年的一些感悟/","link":"","permalink":"http://yoursite.com/2019/02/11/互联网从业5年的一些感悟/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"JAVA垃圾回收相关专题的总结","slug":"JAVA垃圾回收相关专题的总结","date":"2019-02-11T06:18:39.000Z","updated":"2019-02-11T06:18:39.847Z","comments":true,"path":"2019/02/11/JAVA垃圾回收相关专题的总结/","link":"","permalink":"http://yoursite.com/2019/02/11/JAVA垃圾回收相关专题的总结/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"遇到线上服务器Full GC怎么办?","slug":"遇到线上服务器Full-GC怎么办","date":"2019-02-11T06:16:01.000Z","updated":"2019-02-11T06:16:01.190Z","comments":true,"path":"2019/02/11/遇到线上服务器Full-GC怎么办/","link":"","permalink":"http://yoursite.com/2019/02/11/遇到线上服务器Full-GC怎么办/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"记一次线上异常的排查和定位","slug":"记一次线上异常的排查和定位","date":"2019-02-09T12:30:02.000Z","updated":"2019-02-09T15:50:43.191Z","comments":true,"path":"2019/02/09/记一次线上异常的排查和定位/","link":"","permalink":"http://yoursite.com/2019/02/09/记一次线上异常的排查和定位/","excerpt":"","text":"某段时间，线上服务不时会爆出dwr数据异常。初步断定是后端接口返回异常所致。 由于当时我们的服务已经接入ELK，所以第一时间登录kibana后台，按照lucene语法搜索（Tag:”study_online”） AND (message:”exception”)，定位到服务器的异常 异常信息(由于当时的异常日志已经被冲掉了，这是我从网上摘录的)：1234567891011121314java.lang.IllegalStateException: Timed out waiting to add Cmd: 1 Opaque: 1147840 Key: com.stubhub.user.business.entity.UserSession|63C21A07311389A1EC361D834BF46E72 Cas: 0 Exp: 7200 Flags: 1 Data Length: 1748(max wait=10000ms) at net.spy.memcached.protocol.TCPMemcachedNodeImpl.addOp(TCPMemcachedNodeImpl.java:362) at net.spy.memcached.MemcachedConnection.addOperation(MemcachedConnection.java:1267) at com.couchbase.client.CouchbaseConnection.addOperation(CouchbaseConnection.java:277) at net.spy.memcached.MemcachedConnection.enqueueOperation(MemcachedConnection.java:1185) at net.spy.memcached.MemcachedClient.asyncStore(MemcachedClient.java:328) at net.spy.memcached.MemcachedClient.set(MemcachedClient.java:929) at com.stubhub.common.cache.store.couchbase.CouchbaseStore.put(CouchbaseStore.java:148) at com.stubhub.common.cache.store.CompositeCacheStore.put(CompositeCacheStore.java:69) at com.stubhub.common.session.impl.UserSessionCacheManagerImpl.putCrossModuleValue(UserSessionCacheManagerImpl.java:48) at com.stubhub.user.business.manager.impl.UserSessionCacheMgrImpl.putUserSessionToStore(UserSessionCacheMgrImpl.java:269) at com.stubhub.user.business.manager.impl.UserSessionCacheMgrImpl.createUserSession(UserSessionCacheMgrImpl.java:806) at sun.reflect.GeneratedMethodAccessor1305.invoke(Unknown Source) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) 从日志中判断是因为memcached超时抛出的异常。首先查看工程的memcached设置，代码如下123456789101112131415161718192021222324&lt;bean id=&quot;memcachedClient&quot; class=&quot;com.xxx.xxx.cache.impl.KeyPrefixSupportedMemcachedClientFactory&quot;&gt; &lt;property name=&quot;servers&quot; value=&quot;$&#123;memcached_address_list&#125;&quot; /&gt; &lt;property name=&quot;namespace&quot; value=&quot;study_&quot; /&gt; &lt;property name=&quot;protocol&quot; value=&quot;BINARY&quot; /&gt; &lt;property name=&quot;transcoder&quot;&gt; &lt;bean class=&quot;net.spy.memcached.transcoders.SerializingTranscoder&quot;&gt; &lt;property name=&quot;compressionThreshold&quot; value=&quot;16384&quot; /&gt; &lt;/bean&gt; &lt;/property&gt; &lt;property name=&quot;maxReconnectDelay&quot; value=&quot;60&quot; /&gt; &lt;property name=&quot;opTimeout&quot; value=&quot;200&quot;/&gt; &lt;property name=&quot;opQueueMaxBlockTime&quot; value=&quot;400&quot;/&gt; &lt;property name=&quot;timeoutExceptionThreshold&quot; value=&quot;20&quot;/&gt; &lt;property name=&quot;hashAlg&quot;&gt; &lt;value type=&quot;net.spy.memcached.DefaultHashAlgorithm&quot;&gt;KETAMA_HASH&lt;/value&gt; &lt;/property&gt; &lt;property name=&quot;locatorType&quot;&gt; &lt;value type=&quot;net.spy.memcached.ConnectionFactoryBuilder.Locator&quot;&gt;CONSISTENT&lt;/value&gt; &lt;/property&gt; &lt;property name=&quot;failureMode&quot;&gt; &lt;value type=&quot;net.spy.memcached.FailureMode&quot;&gt;Redistribute&lt;/value&gt; &lt;/property&gt; &lt;property name=&quot;useNagleAlgorithm&quot; value=&quot;false&quot; /&gt;&lt;/bean&gt; 可以看到超时时间opTimeout设置的是200毫秒，而opQueueMaxBlockTime是400毫秒opTimeout是操作超时时间，opQueueMaxBlockTime是指操作的最大阻塞时间。那究竟是哪个时间超时导致的呢？可以通过下载memcacheClient源码，搜索“Timed out waiting to add”定位到如下源码12345678910111213141516171819202122232425/* * (non-Javadoc) * * @see net.spy.memcached.MemcachedNode#addOp(net.spy.memcached.ops.Operation) */public final void addOp(Operation op) &#123; try &#123; if (!authLatch.await(1, TimeUnit.SECONDS)) &#123; op.cancel(); getLogger().warn(&quot;Operation canceled because authentication &quot; + &quot;or reconnection and authentication has &quot; + &quot;taken more than one second to complete.&quot;); getLogger().debug(&quot;Canceled operation %s&quot;, op.toString()); return; &#125; if (!inputQueue.offer(op, opQueueMaxBlockTime, TimeUnit.MILLISECONDS)) &#123; throw new IllegalStateException(&quot;Timed out waiting to add &quot; + op + &quot;(max wait=&quot; + opQueueMaxBlockTime + &quot;ms)&quot;); &#125; &#125; catch (InterruptedException e) &#123; // Restore the interrupted status Thread.currentThread().interrupt(); throw new IllegalStateException(&quot;Interrupted while waiting to add &quot; + op); &#125;&#125; 从源码中可以知晓，原因是inputQueue.offer没有正常返回导致的，超过了opQueueMaxBlockTime的时间限制 知道了原因，下面就开始思考怎么解决吧","categories":[],"tags":[{"name":"debug","slug":"debug","permalink":"http://yoursite.com/tags/debug/"}]},{"title":"Markdown基本语法","slug":"Markdown基本语法","date":"2019-02-09T10:32:02.000Z","updated":"2019-02-09T12:51:20.911Z","comments":true,"path":"2019/02/09/Markdown基本语法/","link":"","permalink":"http://yoursite.com/2019/02/09/Markdown基本语法/","excerpt":"","text":"一、标题1234567语法# 这是一级标题## 这是二级标题### 这是三级标题#### 这是四级标题##### 这是五级标题###### 这是六级标题 示例 这是一级标题这是二级标题这是三级标题这是四级标题这是五级标题这是六级标题二、字体12345语法**这是加粗的文字***这是倾斜的文字*`***这是斜体加粗的文字***~~这是加删除线的文字~~ 示例这是加粗的文字这是倾斜的文字`这是斜体加粗的文字这是加删除线的文字 三、引用1234语法&gt;这是引用的内容&gt;&gt;这是引用的内容&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;这是引用的内容 示例 这是引用的内容 这是引用的内容 这是引用的内容 四、分割线12345语法-------******** 示例 五、图片1234语法：![图片alt](图片地址 &apos;&apos;图片title&apos;&apos;)图片alt就是显示在图片下面的文字，相当于对图片内容的解释。图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加 示例 六、超链接123语法：[超链接名](超链接地址 &quot;超链接title&quot;)title可加可不加 示例：简书百度 七、列表 无序列表 12语法：无序列表用 - + * 任何一种都可以 有序列表 12语法：数字加点 例如1.列表内容2.列表内容3.列表内容 列表嵌套 一级无序列表内容 二级无序列表内容 二级无序列表内容 二级无序列表内容 一级无序列表内容 1.二级有序列表内容 2.二级有序列表内容 3.二级有序列表内容 1.一级有序列表内容 二级无序列表内容 二级无序列表内容 二级无序列表内容 2.一级有序列表内容 1.二级有序列表内容 2.二级有序列表内容 3.二级有序列表内容 八、表格123456789101112语法：表头|表头|表头---|:--:|---:内容|内容|内容内容|内容|内容第二行分割表头和内容。- 有一个就行，为了对齐，多加了几个文字默认居左-两边加：表示文字居中-右边加：表示文字居右注：原生的语法两边都要用 | 包起来。此处省略 示例：表头|表头|表头—|:–:|—:内容|内容|内容内容|内容|内容 九、代码语法：单行代码：代码之间分别用一个反引号包起来create table user;代码块：代码之间分别用三个反引号包起来，且两边的反引号单独占一行123代码...代码...代码...","categories":[],"tags":[{"name":"个人博客","slug":"个人博客","permalink":"http://yoursite.com/tags/个人博客/"}]}]}